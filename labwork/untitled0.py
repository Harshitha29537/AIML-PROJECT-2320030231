# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MGmMom4eFId4a_dNv6tBLAlhqPuvg0w2
"""

print('harshitha')

print("harshitha")

0+3+0+8+2+0+0+5

10/2

x="Harshitha"
y=18
print(x)
print(y)

x=str(5)
y=int(3)
z=float(3.89)
print(x)
print(y)
print(z)

x="harshitha"
y=18
z=30.8
print(type(x))
print(type(y))
print(type(z))

x="Harshitha"
print(x)
x='Harshitha'
x=18
print(x)

a=4
A="Harshitha"

myvar='harshitha'
my_var='harshitha'
_my_var='harshitha'
myVar='harshitha'
MYVAR='harshitha'
myvar2='harshitha'
print(myvar)
print(my_var)
print(_my_var)
print(myVar)
print(MYVAR)
print(myvar2)

x,y,z="orange","banana","cherry"
print(x)
print(y)
print(z)

a=_a=A=a2=_a_A=A2=b=_b=B=B3=b3="cherry"
print(a)
print(_a)
print(A)
print(a2)
print(_a_A)
print(A2)
print(b)
print(_b)
print(B)
print(B3)
print(b3)

#List
fruits=["apple","banana","cherry"]
print(fruits)

#tuple
fruits=("apple","banana","cherry")
print(fruits)

#sets
fruits={"apple","banana","cherry"}
print(fruits)

from os import kill
fruits=("apple","banana","cherry")
x,y,z,k=fruits
print(x)
print(y)
print(z)
print(k)

thisdict={
    "brand": "Ford",
    "model": "mustang",
    "year": 1964
}
print(thisdict)

x="python "
y="is "
z="awesome"
print(x + y + z)

import sys
import sys as harshitha
print(sys.version)
print(harshitha.version)

a=100
b=33
if b>a:
  print("b is greater than a")
elif a==b:
  print("a and b are equal")
else:
  print("a is greater than b")

#BFS
from collections import deque

def bfs(g, s):
    q = deque([s])
    v = set()
    v.add(s)
    while q:
        n = q.popleft()
        print(n, end=" ")
        for i in g[n]:
            if i not in v:
                v.add(i)
                q.append(i)

g={'A':['B','C'],'B':['D','E'],'C':['F'],'D':[],'E':[],'F':[]}
bfs(g, 'A')

#encapsulation
class Student:
   def __init__(self, name="Rajaram", marks=50):
      self.name = name
      self.marks = marks

s1 = Student()
s2 = Student("Bharat", 25)

print ("Name: {} marks: {}".format(s1.name, s2.marks))
print ("Name: {} marks: {}".format(s2.name, s2.marks))

#DFS
def dfs(g, s):
    stack = [s]
    v = set()
    while stack:
        n = stack.pop()
        if n not in v:
            print(n, end=" ")
            v.add(n)
            for i in reversed(g[n]):
                if i not in v:
                    stack.append(i)

g = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'],'D':[],'E':[],'F':[]}
dfs(g, 'A')

#encapsulation with DFS
class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)
        if v not in self.graph:
            self.graph[v] = []

    def dfs(self, start):
        stack = [start]
        visited = set()
        while stack:
            node = stack.pop()
            if node not in visited:
                print(node, end=" ")
                visited.add(node)

                for neighbor in reversed(self.graph.get(node, [])):
                    if neighbor not in visited:
                        stack.append(neighbor)


g = Graph()
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('B', 'E')
g.add_edge('C', 'F')

g.dfs('A')

#IDFS
from collections import defaultdict

class graph:

    def __init__(self,vertices):
        self.V = vertices
        self.graph = defaultdict(list)


    def addEdge(self,u,v):
        self.graph[u].append(v)

    def DLS(self,src,target,maxDepth):

        if src == target : return True


        if maxDepth <= 0 : return False


        for i in self.graph[src]:
                if(self.DLS(i,target,maxDepth-1)):
                    return True
        return False

    def IDDFS(self,src, target, maxDepth):

        for i in range(maxDepth):
            if (self.DLS(src, target, i)):
                return True
        return False

g = graph (7);
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 3)
g.addEdge(1, 4)
g.addEdge(2, 5)
g.addEdge(2, 6)

target = 6; maxDepth = 3; src = 0

if g.IDDFS(src, target, maxDepth) == True:
    print ("Target is reachable from source " +
        "within max depth")
else :
    print ("Target is NOT reachable from source " +
        "within max depth")

from matplotlib import pyplot as plt

 #Plotting to our canvas

plt.plot([1,2,3],[4,5,1])

 #Showing what we plotted

plt.show()

x = [5,2,7]
y = [2,16,4]
plt.plot(x,y)
plt.title('Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
plt.show()

from matplotlib.font_manager import FontProperties

font_0 = FontProperties()

font_0.get_family()

font_0.set_family('script MT')

x = [1, 2, 4, 5]
y = [5, 2, 5, 8]
plt.plot(x, y)
plt.xlabel('The x label')
plt.ylabel('The y label')
plt.title('A matplotlib plot', fontproperties = font_0, fontsize = 15, loc = 'left')

plt.plot(x, y, '--*', color = '#70a431')
plt.xlabel('The x label')
plt.ylabel('The y label')
plt.title('A matplotlib plot', fontproperties = font_0, fontsize = 15, loc = 'left')

plt.plot(x, y, '-o', color = 'purple')
plt.xlabel('The x label')
plt.ylabel('The y label')
plt.title('A matplotlib plot', fontproperties = font_0, fontsize = 15, loc = 'left')

from matplotlib import pyplot as plt
from matplotlib import style

style.use('ggplot')
x = [5,8,10]
y = [12,16,6]
x2 = [6,9,11]
y2 = [6,15,7]
plt.plot(x,y,'g',label='line one', linewidth=5)
plt.plot(x2,y2,'c',label='line two',linewidth=5)
plt.title('Epic Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
plt.legend()
plt.grid(True,color='k')
plt.show()

from matplotlib import pyplot as plt

plt.bar([0.25,1.25,2.25,3.25,4.25],[50,40,70,80,20],
label="BMW",color='g',width=.5)
plt.bar([.75,1.75,2.75,3.75,4.75],[80,20,20,50,60],
label="Audi", color='r',width=.5)
plt.legend()
plt.xlabel('Days')
plt.ylabel('Distance (kms)')
plt.title('Information')
plt.show()

import matplotlib.pyplot as plt
population_age = [22,55,62,45,21,22,34,42,42,4,2,102,95,85,55,110,120,70,65,55,111,115,80,75,65,54,44,43,42,48]
bins = [0,10,20,30,40,50,60,70,80,90,100]
plt.hist(population_age, bins, histtype='bar', rwidth=0.8)
plt.xlabel('age groups')
plt.ylabel('Number of people')
plt.title('Histogram')
plt.show()

import numpy as np

x = np.random.random(1000)
y = np.random.random(1000)
plt.scatter(x, y)

import matplotlib.pyplot as plt
x = [1,1.5,2,2.5,3,3.5,3.6]
y = [7.5,8,8.5,9,9.5,10,10.5]

x1=[8,8.5,9,9.5,10,10.5,11]
y1=[3,3.5,3.7,4,4.5,5,5.2]

plt.scatter(x,y, label='high income low saving',color='r')
plt.scatter(x1,y1,label='low income high savings',color='b')
plt.xlabel('saving*100')
plt.ylabel('income*1000')
plt.title('Scatter Plot')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

days = [1,2,3,4,5]

sleeping =[7,8,6,11,7]
eating = [2,3,4,3,2]
working =[7,8,7,2,2]
playing = [8,5,7,8,13]
slices = [7,2,2,13]
activities = ['sleeping','eating','working','playing']
cols = ['c','m','r','b']

plt.pie(slices,
  labels=activities,
  colors=cols,
  startangle=90,
  shadow= True,
  explode=(0,0.1,0,0),
  autopct='%1.1f%%')

plt.title('Pie Plot')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def f(t):
    return np.exp(-t) * np.cos(2*np.pi*t)
t1 = np.arange(0.0, 5.0, 0.1)
t2 = np.arange(0.0, 5.0, 0.02)
plt.subplot(221)
plt.plot(t1, f(t1), 'bo', t2, f(t2))
plt.subplot(222)
plt.plot(t2, np.cos(2*np.pi*t2))
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

df = sns.load_dataset('iris')
df.head()

sns.boxplot( y=df["sepal_length"] );

#One numerical variable, and several groups
#Letâ€™s say we want to study the distribution of a numerical variable, but for each group separately. Here we study the sepal length of 3 species of flower.

#view sourceprint?
# library & dataset


sns.boxplot( x=df["species"], y=df["sepal_length"] )

iris = sns.load_dataset("iris")
sns.catplot(data=iris, orient="h", kind="box");

import seaborn as sns
tips = sns.load_dataset('tips')

tips.head()

#default plot of numeric data
tips.plot()

#plot a single quantitative feature
tips['total_bill'].plot()

#adjust the kind of plot
tips['total_bill'].plot(kind = 'hist')